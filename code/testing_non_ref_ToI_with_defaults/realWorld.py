
''' This is a simulation of the real world. The state of the world is changed and observed by the executer.
There are also some random exogeneous actions that happen with certain probability 'p' when the exectueAction
function is called by the executer.

The state of the world changes according to the program ASP_World.sp, which will take attempts of actions
(either robot actions or exogeneous actions that have been randomly generated by this program), and it will
retrun an output with the occurences of the actions that actually happened, and the new state of the world
after those attempts. The ASP history incudes attempts and the executable conditons are defined with a relation
'impossible' which will not let them happen if the domain does not allow it so. As well as the domain
executable conditons, we have included conditions for the concurrency of exo_actions and the robot actions,
for example, an exogeneous move of an object O is impossible if a robot action of picking the object up occurs
at the same step.

The state of the world is kept in the dictionary dic_WorldState
which holds a string that represents the head of the fluent and its first variable, for example 'loc(rob', and
a string with the second variable 'library' as the value of the key. In the case of having one variable, the value of the
key is None.
If the key 'locked(library' does is not in the key list of the dictionary, the library is then unlocked,
and if 'in_hand(rob' is not part of the key set, then the robot is not holding anything in his hand.
Example {'loc(rob,':'library', 'locked(library':None, 'loc(book1': 'library', 'loc(book2':'kitchen'}

The observations that the robot make are represented by the robotObserves function, and this observations
are constrained by the location of the robot,. For example, the robot cannot observe an object being in a
location where ther robot is not. If an observation of the location of book1 being in the library is required,
and the robot is in the kitchen, it will return an observation of book1 being or not in the kitchen.
'''
from sets import Set
import subprocess
import random

class World(object):
	def __init__(self,new_domain_info_formatting,dic_initial_conditions, this_seed):
		print '\n-------------------------------------------------------------------------------------------------\n'
		print 'World initial conditions: ' + str(dic_initial_conditions)
		self.domain_info_formatting = new_domain_info_formatting
		self.dic_WorldState = dic_initial_conditions
		reader = open(self.domain_info_formatting.preASP_domain_file, 'r')
    		pre_asp = reader.read()
    		reader.close()
    		self.pre_asp_split = pre_asp.split('\n')
		self.history_marker_index = self.pre_asp_split.index(self.domain_info_formatting.history_marker) + 1
		self.exo_action_happened = False
		self.history = []
		self.executionTimeUnits = 0
		self.executedSteps = 0
		self.domain_locations = self.domain_info_formatting.get_all_basic_subsorts('#room')
		random.seed(this_seed)

	def __update_state(self,answer_split):
		self.dic_WorldState = {}
		my_fluents = [entry[entry.find('(')+1:entry.find(')')+1] for entry in answer_split if 'holds' in entry]
		my_fluents_splitted = [v.replace(')','').split(',') for v in my_fluents]
		for split_fluent in my_fluents_splitted:
			## if my fluent had a comma in it, for example 'loc(rob1,kitchen)', then the splitted version is a list with two elements,
			## and  the dictionary will have a key that corresponds to the first element of the list 'loc(rob1', with value
			## that corresponds to the second part of the fluent, i.e. 'kitchen' (the brackets are removed for formatting )
			if len(split_fluent)>1:
				self.dic_WorldState[split_fluent[0]] = split_fluent[1]
			## if my fluent did not have a comma, for example 'locked(library)', then the splitted version is a list wit only one element,
			## so the dictionary will have a key 'locked(library' with corresonding value None.
			else: self.dic_WorldState[split_fluent[0]] = None

	def __getexecutionTimeUnits(self,action):
		if(action[0:4] == 'move'):
			return 3
		if(action[0] == 'p'):
			return 1
		if(action[0:6] == 'unlock'):
			return 1

	def __get_exo_action(self,action):
		exo_action = ''
		if(random.random()<1):
			exo_action = random.choice(['exo_lock(library)','exo_move(book1,','exo_move(book2,'])
			if 'exo_move' in exo_action: exo_action = exo_action + random.choice(list(self.domain_locations))+')'
		return exo_action

	def __runASPDomain(self,input):
		asp_split = self.pre_asp_split[:self.history_marker_index] + input + self.pre_asp_split[self.history_marker_index:]
		asp = '\n'.join(asp_split)
		f1 = open(self.domain_info_formatting.asp_World_file, 'w')
		f1.write(asp)
		f1.close()
		print (self.domain_info_formatting.asp_World_file)
		answer = subprocess.check_output('java -jar '+ self.domain_info_formatting.sparc_path + ' ' +self.domain_info_formatting.asp_World_file+' -A',shell=True)
		answer_split = answer.strip('{}\n').split(', ')
		return answer_split

	def executeAction(self,action):
		exo_action = ''
		input = self.domain_info_formatting.dic_state_to_obs_list(self.dic_WorldState,0) + ['attempt('+ action +',0).']
		print '\nAttempt: ' + action
		if(self.exo_action_happened == False):
			exo_action = self.__get_exo_action(action)
			if(exo_action != ''):
				input = input + ['attempt('+ exo_action +',0).']
				print 'Attempt: ' + exo_action

		answer_split = self.__runASPDomain(input)
		self.executionTimeUnits += self.__getexecutionTimeUnits(action)
		self.executedSteps += 1
		self.__update_state(answer_split)
		if answer_split == None: return

		if('occurs('+ action +',0)' in answer_split):
			self.history.append(action)
			print action+ ' happened.'
		else:
			self.history.append(action + " (FAILED) ")
			print action+ ' did not happen.'

		if('occurs('+ exo_action +',0)' in answer_split):
			self.history.append(exo_action)
			self.exo_action_happened = True
 			print('\t\t\t\t\t'+exo_action + ' HAPPENED!!!!')
		else:
			print( exo_action + ' did not happen.')


	def get_exo_action_happened(self):
		return self.exo_action_happened

	def getHistory(self):
		return self.history

	def getExecutionTimeUnits(self):
		return self.executionTimeUnits

	def getExecutedSteps(self):
		return self.executedSteps

	#this version uses a version of asp that returns the values that the robot observes upon different request.
	def robotObserves(self,fluent_to_observe):
		print '\nObserving in the real world.'
		input = self.domain_info_formatting.dic_state_to_obs_list(self.dic_WorldState,0) + ['try_observing(rob1,'+ fluent_to_observe +',0).']
		answer_split = self.__runASPDomain(input)
		holds_list = [v for v in answer_split if 'holds' in v]
		observed_list = [v for v in answer_split if 'observed' in v]
		return Set(observed_list)



	def getRealValue(self,fluent):
		fluent_split = fluent.strip(')').split(',')
		if fluent_split[0] not in self.dic_WorldState: return fluent,'false'
		return fluent, str(fluent_split[1] == self.dic_WorldState[fluent_split[0]]).lower()
